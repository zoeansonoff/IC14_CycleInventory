//When the parameters in a method have the same as instance variables you can differentiate them by using the THIS parameter.
//The new operator: ALLOCATES MEMORY, USED TO CREATE OBJECT OF CLASS, ASSOCIATES AN OBJECT WITH A VARIABLE NAME.
//A variable whose meaning is confined to an object of a class is called a/an: INSTANCE VARIABLE.
//A variable whose meaning is confined to a method definition is called an/a: LOCAL VARIABLE
//The parameter this refers to THE CALLING OBJECT
//Two methods that are expected to be in all Java classes are: **toString and equals**
//In Java, call-by-value is only used with: PRIMITIVE TYPES
//A program whose only task is to test a method is called a/an: DRIVER/DEMO PROGRAM
//The principals of object oriented programming include: ENCAPSULATION, INHERITANCE, POLYMORPHISM
//If you choose to implement the equals method in your code, you must OVERRIDE the equals method from the Object class.
//You cannot create an object using a/an: ABSTRACT CLASS CONTRUCTOR
//Assigning an object of an ancestor class to a descendent class is called: DOWNCASTING
//Assigning an object of a derived class to a variable of a base class is called: UPCASTING
//An abstract method cannot be modified by: PRIVATE
//A class with no abstract methods is called a CONCRETE CLASS
//BINDING refers to the process of associating a method definition with a method invocation.
//Try blocks contain code that could possibly: THROW AN EXCEPTION
//The Exception class belongs to the package: **java.lang**
//The catch block has ONE parameter.
//When defining your own exception class, you extend an existing exception class. This is an example of: INHERITANCE
//When using the Scanner class one should account for a/an: **InputMismatchException**
//Exceptions that are subject to the catch or declare rule are called: CHECKED EXCEPTIONS
//A runtime exception is a/an: UNCHECKED EXCEPTION
//A FINALLY block executes regardless of whether an exception occurs.
//A recursive method is one that: INVOKES ITSELF WITH SMALLER INPUT
//All recursive methods have a/an ITERATIVE equivalent method.
//When defining recursive valued methods you should: ENSURE THERE IS NO INFINITE RECURSION, EACH STOPPING CASE RETURNS THE CORRECT VALUE FOR THAT CASE, & FINAL VALUE RETURNED BY METHOD IS CORRECT VALUE
//A recursive solution can be preferable to an iterative solution because: RECURSIVE CAN BE EASIER TO UNDERSTAND THAN ITERATIVE ONES.
//During recursion, if the stack attempts to grow beyond its limit, a STACK OVERFLOW occurs.
//Regarding recursion, if a base case is never reached the result is: INFINITE RECURSION
//All recursive methods must have a/an: STOPPING CASE
//The underlying data structure used by the computer during recursion is a: STACK
//An INPUT STREAM allows data to flow into your program.
//In Java, when you open a text file you should account for a possible: **FileNotFoundException**
//There are two common classes used for reading from a text file. They are: **BufferReader and Scanner**
//The scanner class has a series of methods that checks to see if there is any more well-formed input of the appropriate type. These methods are called **hasNext** methods:
//All of the following are methods of the Scanner class except: **nextChar()**
//The method **read()** reads a single character from an input stream.
//The stream that is automatically available to your Java code is: **System.out, System.in, System.err**
//All of the following are methods of the File class except: **getDirectory()**
//Files whose contents must be handled as sequences of binary digits are called: BINARY FILES
//The class ObjectOutputStream contains all of the following methods except: **println()**
//The method **flush()**from the File class forces a physical write to the file of any data that is buffered.
//The class ObjectInputStream contains all of the following methods except: **readLine()**
//The read() method of the class RandomAccessFile returns the type: **int**
//Binary files store data in the same format that is used by any common text editor - FALSE
//Binary files can be handled more efficiently than text files. - TRUE
//The preferred stream classes for processing binary files are ObjectInputStream and ObjectOutputStream. - TRUE
//2 differences between a binary and a text file: Text has letters and is readable to humans whereas binary has 0 and 1 and is readable to computers. Binary files do not use line breaks, where text files often do.
